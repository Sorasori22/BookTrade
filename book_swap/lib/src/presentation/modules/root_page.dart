import 'package:auto_route/auto_route.dart';
import 'package:book_swap/src/core/account/current_account_provider.widget.dart';
import 'package:book_swap/src/core/helpers/build_context_helper.dart';
import 'package:book_swap/src/core/helpers/logger.dart';
import 'package:book_swap/src/features/banner/providers/banner_provider.dart';
import 'package:book_swap/src/features/notification/notification_schema.schema.dart';
import 'package:book_swap/src/features/notification/providers/notification_list_pagination_provider.dart';
import 'package:book_swap/src/features/trade_request/providers/trade_request_list_provider.dart';
import 'package:book_swap/src/features/trade_request/trade_request_schema.schema.dart';
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:kimapp_supabase_helper/supabase_provider.dart';
import 'package:onesignal_flutter/onesignal_flutter.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../../core/account/account.dart';
import '../../features/chat/providers/chat_list_pagination_provider.dart';
import '../../features/message/message_schema.dart';
import '../../features/message/message_schema.schema.dart';
import '../../features/message/providers/message_list_pagination_provider.dart';
import '../../features/notification/providers/notification_unread_count_provider.dart';
import '../../features/trade_request/providers/my_trade_request_list_provider.dart';
import '../../features/trade_request/trade_request_schema.dart';
import '../router/app_router.gr.dart';
import '../startup/tasks/init_notification_task.dart';

@RoutePage()
class RootPage extends ConsumerStatefulWidget {
  const RootPage({super.key});

  @override
  ConsumerState<RootPage> createState() => _RootPageState();
}

class _RootPageState extends ConsumerState<RootPage> with LoggerMixin {
  RealtimeChannel? _tradeRequestChannel;
  RealtimeChannel? _messageChannel;
  RealtimeChannel? _tradeMessageChannel;
  RealtimeChannel? _notificationChannel;

  @override
  void initState() {
    super.initState();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _showBanner();
      _listenTradeRequestRealtime();
      _listenMessageRealtime();
      _listenTradeMessageEvent();
      _listenNotificationRealtime();
    });

    notificationClickEventHandler(ref, (OSNotificationClickEvent event) {
      try {
        final payload = event.notification.additionalData;
        logInfo('Got notification payload: $payload');
        if (payload == null) return;

        throw UnimplementedError();
      } catch (e) {
        logError('Error handling notification click', e);
      }
    });
  }

  void _listenNotificationRealtime() {
    final sb = ref.read(supabaseProvider).client;
    _notificationChannel = sb.channel('notifications');

    _notificationChannel!
        .onPostgresChanges(
          event: PostgresChangeEvent.all,
          schema: 'public',
          table: NotificationTable.table,
          filter: PostgresChangeFilter(
            type: PostgresChangeFilterType.eq,
            column: NotificationTable.userId,
            value: ref.read(currentUserIdProvider),
          ),
          callback: (payload) {
            ref.invalidate(notificationListPaginationProvider);
            ref.invalidate(notificationUnreadCountProvider);
          },
        )
        .subscribe();
  }

  void _listenTradeMessageEvent() {
    final sb = ref.read(supabaseProvider).client;
    _tradeMessageChannel = sb.channel('trade_messages');

    _tradeMessageChannel!
        .onPostgresChanges(
          event: PostgresChangeEvent.all,
          schema: 'public',
          table: MessageTable.table,
          filter: PostgresChangeFilter(
            type: PostgresChangeFilterType.eq,
            column: MessageTable.senderId,
            value: ref.read(currentProfileIdProvider),
          ),
          callback: (payload) {
            if (payload.eventType == PostgresChangeEvent.insert) {
              final messageType = MessageType.values.byName(payload.newRecord['type']);
              // These messages are generated by the system, so we need to manually invalidate the message
              // since message only listen to realtime of room
              if (messageType == MessageType.requestStarted ||
                  messageType == MessageType.offeredBook ||
                  messageType == MessageType.tradeConfirmed) {
                ref.invalidate(messageListPaginationProvider);
                ref.invalidate(chatListPaginationProvider);
              }
            }
          },
        )
        .subscribe();
  }

  void _listenMessageRealtime() {
    final sb = ref.read(supabaseProvider).client;
    _messageChannel = sb.channel('messages');

    _messageChannel!
        .onPostgresChanges(
          event: PostgresChangeEvent.all,
          schema: 'public',
          table: MessageTable.table,
          filter: PostgresChangeFilter(
            type: PostgresChangeFilterType.eq,
            column: MessageTable.recipientId,
            value: ref.read(currentProfileIdProvider),
          ),
          callback: (payload) {
            ref.invalidate(chatListPaginationProvider);

            if (payload.eventType == PostgresChangeEvent.insert) {
              final messageType = MessageType.values.byName(payload.newRecord['type']);
              // These messages are generated by the system, so we need to manually invalidate the message
              // since message only listen to realtime of room
              if (messageType == MessageType.requestStarted ||
                  messageType == MessageType.offeredBook ||
                  messageType == MessageType.tradeConfirmed) {
                ref.invalidate(messageListPaginationProvider);
              }
            }
          },
        )
        .subscribe();
  }

  void _listenTradeRequestRealtime() {
    final sb = ref.read(supabaseProvider).client;
    _tradeRequestChannel = sb.channel('trade_requests');

    _tradeRequestChannel!
        .onPostgresChanges(
          event: PostgresChangeEvent.all,
          schema: 'public',
          table: TradeRequestTable.table,
          filter: PostgresChangeFilter(
            type: PostgresChangeFilterType.eq,
            column: TradeRequestTable.ownerId,
            value: ref.read(currentProfileIdProvider),
          ),
          callback: (payload) {
            ref.invalidate(tradeRequestListProvider);
          },
        )
        .subscribe();
  }

  Future<void> _showBanner() async {
    final banner = await ref.read(bannerProvider.future);
    if (banner == null) return;

    context.pushRoute(BannerRoute());
  }

  @override
  void dispose() {
    _tradeRequestChannel?.unsubscribe();
    _messageChannel?.unsubscribe();
    _tradeMessageChannel?.unsubscribe();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return CurrentAccountProviderScope(
      child: AutoTabsScaffold(
        routes: const [
          HomeRoute(),
          BookRoute(),
          MessageRoute(),
          ProfileRoute(),
        ],
        bottomNavigationBuilder: (context, tabsRouter) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Divider(height: 0, thickness: 0.2),
              BottomNavigationBar(
                currentIndex: tabsRouter.activeIndex,
                type: BottomNavigationBarType.fixed,
                selectedIconTheme: context.theme.iconTheme.copyWith(
                  color: context.colors.primary,
                ),
                selectedFontSize: 12,
                onTap: tabsRouter.setActiveIndex,
                items: [
                  BottomNavigationBarItem(
                    icon: Icon(Icons.home_outlined),
                    activeIcon: Icon(Icons.home),
                    label: 'Home',
                  ),
                  BottomNavigationBarItem(
                    icon: Icon(Icons.menu_book_outlined),
                    activeIcon: Icon(Icons.menu_book),
                    label: 'Browse',
                  ),
                  BottomNavigationBarItem(
                    icon: Consumer(
                      builder: (context, ref, child) {
                        final tradeRequestCount = ref.watch(
                          myTradeRequestListProvider(status: TradeRequestStatus.pending)
                              .select((state) => state.valueOrNull?.length ?? 0),
                        );

                        if (tradeRequestCount == 0) return Icon(Icons.messenger_outline);

                        return Badge.count(
                          count: tradeRequestCount,
                          child: Icon(Icons.messenger_outline),
                        );
                      },
                    ),
                    activeIcon: Icon(Icons.messenger),
                    label: 'Message',
                  ),
                  BottomNavigationBarItem(
                    icon: Icon(Icons.person_2_outlined),
                    activeIcon: Icon(Icons.person),
                    label: 'Profile',
                  ),
                ],
              ),
            ],
          );
        },
      ),
    );
  }
}
