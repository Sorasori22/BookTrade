---
description: Kimapp Flutter Project Structure and Generation
globs: *.dart
alwaysApply: false
---
# Kimapp Flutter Project - Guideline

## Project Scaffolding and Generation

### Project Initialization
- To create a new Flutter project using the Kimapp template, run:
  ```bash
  mason make kimapp
  ```
- This will generate a scaffold project integrated with Supabase backend.
- During generation, you'll be prompted for:
  - `project_name`: Your project name in snake_case (used in imports and pubspec.yaml)
  - `sentry_dsn`: Optional Sentry DSN for error tracking

### Feature Generation
- To add a new feature to the project, run:
  ```bash
  mason make kimapp_simple_feature
  ```
- This brick generates necessary files for a new feature, prompting for:
  - `name`: Feature object name in singular form
  - `id_data_type`: Data type for the object's ID (int or String)
  - `generate_ui`: Whether to generate UI components (default: false)
- When UI generation is selected, it includes starter UI components ready to use

## Project Structure

The project follows a feature-first architecture with a centralized presentation layer:

```
lib/
├── gen/                    # Generated code for assets
│   ├── assets.gen.dart
│   └── gen.dart
├── src/
│   ├── core/               # Core functionality and utilities
│   │   ├── account/        # Account management
│   │   ├── app/            # App-level configuration
│   │   ├── cache_manager/  # Caching functionality
│   │   ├── device/         # Device information
│   │   ├── errors/         # Error handling
│   │   ├── file/           # File operations
│   │   └── helpers/        # Utility helpers
│   ├── features/           # Feature modules
│   │   ├── auth/           # Authentication feature
│   │   │   ├── core/       # Core auth functionality
│   │   │   ├── params/     # Request parameters
│   │   │   ├── providers/  # Riverpod providers
│   │   │   ├── repositories/ # Repository interfaces
│   │   │   └── auth.dart   # Main entry point
│   │   └── [feature_name]/ # Other features follow similar pattern
│   │       ├── params/     # Request parameters 
│   │       ├── providers/  # State management
│   │       ├── i_[feature]_repo.dart # Repository interface
│   │       └── [feature]_schema.dart # Schema definition
│   └── presentation/       # UI layer (centralized)
│       ├── app/            # App-wide UI configuration
│       ├── modules/        # Feature-specific UI components
│       │   ├── auth/       # Auth screens
│       │   ├── splash/     # Splash screens
│       │   └── [feature]/  # Feature-specific screens
│       ├── router/         # App routing
│       ├── startup/        # App initialization
│       │   └── tasks/      # Startup tasks
│       └── widgets/        # Reusable UI components
│           ├── buttons/
│           ├── components/
│           ├── dialogs/
│           ├── feedback/
│           ├── forms/
│           ├── layouts/
│           ├── lists/
│           ├── navigation/
│           ├── theme/
│           └── typography/
├── config.dart             # Configuration
├── main.dart               # Main entry point
├── main_dev.dart           # Development entry point
└── main_stage.dart         # Staging entry point
```

## Schema System Guide

The project uses `kimapp_generator` package for database schema and model generation:

### Core Concepts
1. **Schema Definition**: Annotate classes with `@Schema` to define database tables
2. **Fields**: Define table columns using `Field<T>` with appropriate types
3. **Models**: Generate multiple model variations from a single schema
4. **ID Types**: Create type-safe ID classes for improved type safety


### Code Generation
After defining schemas, run:
```bash
dart run build_runner build  # One-time build
dart run build_runner watch  # Watch for changes
```

## Key Development Guidelines

### Immutability Principles
- **Prefer Immutable Collections**: Use `IList`, `IMap`, and `ISet` from the `fast_immutable_collections` package
- **When to use Immutable Collections**:
  - For all model/entity data structures
  - For all state management (Riverpod providers, Bloc states)
  - For any data that shouldn't be accidentally mutated

- **When to use mutable Lists**:
  - Widget constructors when better performance is needed
  - Temporary local variables that don't escape function scope
  - Performance-critical sections where immutability overhead is measurable

### Freezed Integration
- All models should use Freezed for immutability
- Combine with `fast_immutable_collections` for deeply immutable structures

### Type Safety
- Always use type-safe ID classes generated by the schema system
- Prefer strong typing over generic types (`dynamic`, `Object`)
- Use non-nullable types by default, nullable types only when necessary
